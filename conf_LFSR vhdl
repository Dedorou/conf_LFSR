library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.numeric_std.all;

entity conf_LFSR is 
generic(
	BITNES : natural := 32;
	TEST : natural := 5 -- log2(bitnes) СЃ РѕРєСЂСѓРіР»РµРЅРёРµРј  Р±РѕР»СЊС€СѓСЋ СЃС‚РѕСЂРѕРЅСѓ
);
port(
	clk, reset : in std_logic;
	input_polynom : in std_logic_vector(BITNES-1 downto 0);
	polynom_WE : in std_logic;
	outputLFSR : out std_logic_vector(BITNES-1 downto 0)
);
end conf_LFSR;


architecture RTL of conf_LFSR is
signal configure_register_output : std_logic_vector(BITNES-1 downto 0);
signal LFSR : std_logic_vector(BITNES-1 downto 0);
signal coder_ind : integer :=0;
signal LFSR_shift_in : std_logic;
begin

POLYNOM_REGISTER: process(clk) 
begin
if(rising_edge(clk)) then
    if(reset = '1') then
        configure_register_output <= (others => '0');
    else
	   if(polynom_WE = '1') then	
			configure_register_output <= input_polynom;
	   else
			configure_register_output <= configure_register_output;
	   end if;	
	end if;
end if;
end process;

process(input_polynom) 
begin
	for k in BITNES-1 downto 0 loop
		if(input_polynom(k) = '1') then
			coder_ind <= k;
		end if;
	end loop;
end process;

LFSR_module: process(clk, coder_ind)
variable LFSR_output : std_logic_vector(BITNES-1 downto 0) := (0 => '1',others => '0');
begin
if(rising_edge(clk)) then
    if(reset = '1') then
        LFSR_output := (0 => '1',others => '0');
    else
       for k in 1 to BITNES-1 loop 
         if k<=(coder_ind-1) then
            LFSR_output(k):=LFSR_output(k-1);
         end if;
       end loop;
	   LFSR_output(0) := LFSR_shift_in;
	end if;
end if;
	outputLFSR <= LFSR_output;
	LFSR <= LFSR_output;
end process;

process(LFSR, configure_register_output)
variable tmp : std_logic_vector(BITNES downto 0);
begin
	tmp := (others => '0');
	for k in BITNES-1 downto 0 loop
	   if k<=(coder_ind-1) then
		tmp(k) := tmp(k+1) xor (configure_register_output(k) and LFSR(k));
	   end if;
	end loop;
    LFSR_shift_in <= tmp(0);
end process;



end RTL;
